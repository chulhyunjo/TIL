# 애너테이션

> 커스텀 메타데이터를 정의하고 메타데이터를 소스코드 상의 선언, 식, 전체 파일 등의 요소에 엮는 방법을 제공

```kotlin
import org.junit.Test

class MyTestCase {
    @Test
    fun testOnePlusOne(){
        // assert: 오류가 발생하지 않고 테스트를 실행할 때만 활성화
        assert(1 + 1 = 2)
    }
}
```

- 자바와는 달리 식에도 적용을 할 수 있다.

```kotlin
val s = @Suppress("UNCHEKED_CAST") objects as List<String>

// 여러 애너테이션을 적용
@[Sychronized Strictfp]
fun main() {}

// 주생성자에 적용
class A @MyAnnotation constructor()

// 애너테이션을 정의
annotation class MyAnnotation
@MyAnnotation fun annotatedFun() {}
```



- 자바는 인터페이스로 구성되지만, 코틀린 애너테이션은 특별한 종류의 클래스로 구성

- 코틀린 1.3부터는 내포된 클래스, 인터페이스, 객체를 애너테이션 본문에 넣을 수 있다.

```kotlin
annotation class MyAnnotation {
    // 일반 클래스와 달리 애너테이션 클래스에는 멤버나 부생성자, 초기화 코드가 없다.
    val text = "???" // Error
    
    companion object {
        val text = "???"
    }
    
    // 애트리뷰트를 추가하고 싶으면 생성자 파라미터를 통해야만 한다.
    annotation class MyAnnotation(val text: String) // 항상 val로 선언해야 한다.
    @MyAnnotation("Some useful info") fun annotatedFun(){}
    
    // 생성자 파라미터가 프로퍼티 역할을 함께 담당
    annotation class Dependency(val arg: String, val componentNames:String = "Core")
    annotation class Component(val name: String = "Core")
    
    @Component("I/O")
    class IO
    
    @Component("Log")
    @Dependency("I/O")
    class Logger
    
    @Component
    @Dependency("I/O", "Log")
    
    // 애너테이션은 클래스의 일종이지만 인스턴스 생성 불가
    // 얻기 위해서는 리플렉션 API를 활용해야 한다.
    // 컴파일 시에만 평가되므로 애너테이션 인자에 임의의 식을 넣을 수 없다.
    // 컴파일러는 애너테이션 파라미터로 사용할 수 있는 타입의 종류는
    /**
    	Int, Boolean, Double 등 원시 타입, String
    	이넘
    	다른 애너테이션
    	클래스 리터럴
    	위에 나열된 타입들로 이루어진 배열
    */
    
    // 다른 애너테이션을 인자로 사용하는 경우 @접두사를 안 붙여도 된다.
    annotation class Dependency(varag val componentNames:String)
    annotation class Component(
        val name: String="Core", val dependency:Dependency = Dependency()
    )
}
```



- KClass
  - 클래스 이름 뒤에 ::class를 붙여서 클래스 리터럴을 만든다.

```kotlin
import kotlin.reflect.Kclass

annotation class Dependency(varag val componentClasses: KClass<*>)

annotation class Component(
	val name: String = "core",
	val dependency: Dependency = Dependency()
)

@Component("I/O")
class IO

@Component("Log", Dependency(IO::class))
class Logger

@Compnent(dependency = Dependency(IO::class, Logger::class))
class Main
```

