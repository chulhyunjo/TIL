# 루프

- while, do-while 루프

```kotlin
fun main() {
    var sum = 0
    var num: Int
    
    do {
        num = readLine()!!.toInt()
        sum += sum
    } while (num != 0)
    
    println("Sum: $sum")
}
```

- do 와 while 키워드 사이에 있는 루프 몸통을 실행한다.
- while 키워드 다음에 있는 조건을 평가한다. 이 값이 참이면 돌아가고, 이 값이 거짓이면 루프 문 다음에 있는 문을 실행
- 몸통을 실행한 이후에 조건을 검사하므로 루프 몸통이 최소 1번은 실행된다.



```kotlin
fun main(){
    val num = Random.nextInt(1, 101)
    var guess = 0

    while(guess != num) {
        guess = readLine()!!.toInt()
        if (guess < num) println("Too small")
        else if (guess > num) println("Too big")
    }

    println("its $num")
}	
```



- for루프와 이터러블

```kotlin
fun main() {
    val a = IntArray(10){it*it}
    var sum = 0
    for (x in a) {
        sum += x
    }

    println("Sum: $sum")
}
```

- 이터레이션 대상을 담을 변수 정의 `x`

- 이터레이션에 사용할 값들이 담겨 있는ㄴ 컨테이너를 계산하기 위한 식 `a`
- 루프 몸통에 해당하는 문 `{sum+=1}`. 이터레이션 시 이 몸통이 실행된다.

```kotlin
fun parseIntNumber(s: String, fallback: Int = -1): Int {
    var num = 0

    if (s.length !in 1..31) return fallback

    for ( c in s ){
        if (c !in '0'..'1') return fallback
        num = num * 2 + (c - '0')
    }
    return num
}
```

- 문자열과 배열에는 원소나 문자의 인덱스 범위를 제공하는 `indices` 프로퍼티가 들어있다.

```kotlin
fun main(){
    val a = IntArray(10){it * it}
    for (i in a.indices step 2){
        a[i] *= 2
    }
}
```



- 루프 제어 흐름 변경하기: break, continue

  - break는 즉시 루프를 종료시키고, 실행 흐름이 루프 다음 문으로 이동하게 만든다.
  - continue는 현재 루프 이터레이션(iteration)을 마치고 다음 조건 검사로 이동하게 한다.

  ```kotlin
  fun main() {
      val num = Random.nextInt(1, 101)
  
      while (true){
          val guess = readLine()!!.toInt()
          if(guess < num) println("to small")
          else if(guess > num) println("to big")
          else break
      }
  }
  ```

  ```kotlin
  fun countLetters(text: String): IntArray {
      val counts = IntArray('z' - 'a' + 1)
  
      for (char in text) {
          val charLower = char.lowercaseChar()
          if (charLower !in 'a'..'z') continue
          counts[charLower - 'a']++
      }
      return counts
  }
  ```

  

- 내포된 루프와 레이블

  ```kotlin
  fun indexOf(subarray: IntArray, array:IntArray): Int {
      outerLoop@ for (i in array.indices) {
          for (j in subarray.indices) {
              if(subarray[j] != array[i+j]) continue@outerLoop
          }
          return i 
      }
      return - 1
  }
  ```

  - 바깥 쪽 루프에 `outlerLoop@`레이블을 붙이고, 하위 배열의 오프셋을 찾는 과정에서 하위 배열과 배열의 원소가 일치하지 않는다는 사실을 발견하자마자 `continue@outerLoop`을 활용해 바깥 루프의 현재 이터레이션을 끝내고 다음 이터레이션을 시작.