> 데이터 구조 활용

- 데이터 구조를 활용하기 위해서는 method를 활용
  - 메서드는 클래스 내부에 정의한 함수, 사실상 함수 동일
  - 쉽게 설명하면 객체의 기능

- data.method() 형태로 활용
  - List.append(10)
  - String.split()



> 파이썬 공식 문서의 표기법

- python 구문이 아니며, 문법을 표현하기 위한 것
- ex) str.**replace**(old, new**[, count]**)
  - old, new는 필수 / [,count]는 선택적 인자를 의미



## 문자열

- 문자들의 나열(sequence of characters)
  - 모든 문자는 str타입(변경 불가능한 immutable)
- 문자열은 작은 따옴표나 큰 따옴표로 표기
  - 문자열을 묶을 때 동일한 문장부호를 활용

| 문법        | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| s.find(x)   | x의 첫 번째 위치를 반환. 없으면 -1을 반환                    |
| s.index(x)  | x의 첫 번째 위치를 반환. 없으면 오류 발생                    |
| s.isalpha() | 알파벳 문자 여부<br />* 단순 알파벳이 아닌 유니코드 상 Letter(한국어 포함) |
| s.isupper() | 대문자 여부                                                  |
| s.islower() | 소문자 여부                                                  |
| s.istitle() | 타이틀 형식 여부                                             |



### 변경 메서드

| 문법                            | 설명                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| s.replace(old, new[, count])    | 바꿀 대상 글자를 새로운 글자로 반환                          |
| s.strip([chars])                | 공백이나 특정 문자를 제거                                    |
| s.split(sep=None, maxsplit =-1) | 공백이나 특정 문자를 기준으로 분리                           |
| 'separator'.join([iterable])    | 구분자로 iterable을 합침                                     |
| s.capitalize                    | 가장 첫번째 글자를 대문자로 변경                             |
| s.title                         | 문자열 내 띄어쓰기 기준으로 각 단어의 첫 글자는 대문자, 나머지는 소문자 |
| s.upper()                       | 모두 대문자로 변경                                           |
| s.lower()                       | 모두 소문자로 변경                                           |
| s.swapcase()                    | 대↔소문자 서로 변경                                          |



## 리스트

### 리스트의 생성과 접근

- 리스트는 대괄호 혹은 list()를 통해 생성
  - 파이썬은 어떠한 자료형도 저장 가능
  - 가변 자료형



### 리스트 메서드

| 문법                   | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| L.append(x)            | 리스트 마지막에 항목 x를 추가                                |
| L.insert(i, x)         | 리스트 인덱스 i에 항목 x를 삽입                              |
| L.remove(x)            | 리스트 가장 왼쪽에 있는 항목(첫 번째) x를 제거<br />항목이 존재하지 않을 경우, ValueError |
| L.pop()                | 리스트 가장 오른쪽에 있는 항목을 반환 후 제거                |
| L.pop(i)               | 리스트의 인덱스 i에 있는 항목을 반환 후 제거                 |
| L.extend(m)            | 순회형 m의 모든 항목들의 리스트 끝에 추가(+=과 같은 기능)    |
| L.index(x, start, end) | 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환 |
| L.reverse()            | 리스트를 거꾸로 정렬                                         |
| L.sort()               | 리스트를 정렬(매개변수 이용가능)                             |
| L.count()              | 리스트에서 항목 x가 몇 개 존재하는지 갯수를 반환             |



## Set

- 순서에 상관없는 데이터들의 묶음
  - 순서가 없기 때문에 인덱스를 이용한 접근 불가능
- 수학에서의 집합을 표현한 컨테이너



| 문법            | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| s.copy          | 셋의 얕은 복사본을 반환                                      |
| s.add(x)        | 항목 x가 셋s에 없다면 추가                                   |
| s.pop()         | 셋 s에서 랜덤하게 항목을 반환하고, 해당 항목을 제거<br />set이 비어있는 경우, KeyError |
| s.remove()      | 항목 x를 셋s에서 삭제<br />항목이 존재하지 않을 경우, KeyError |
| s.discard(x)    | 항목 x가 셋s에 있는 경우, 항목 x를 셋 s에서 삭제             |
| s.update(t)     | 셋 t에 있는 모든 항목x를 셋s에서 삭제                        |
| s.clear()       | 모든 항목을 제거                                             |
| s.isdisjoint(t) | 셋s가 셋 t의 서로 같은 항목을 하나라도 갖고 있지 않은 경우, True 반환 |
| s.issubset(t)   | 셋 s가 셋 t의 하위 셋인 경우, True 반환                      |
| s.issuperset(t) | 셋 s가 셋 t의 상위 셋인 경우, True반환                       |



## 딕셔너리

| 문법              | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| d.clear()         | 모든 항목을 제거                                             |
| d.copy()          | d의 얕은 복사본을 반환                                       |
| d.keys()          | 모든 키를 담은 리스트                                        |
| d.values()        | 모든 값을 담은 리스트                                        |
| d.items()         | 모든 키-값을 쌍으로 담은 뷰를 반환                           |
| d.get(k)          | 키 k의 값을 반환하는데, 키 k가 딕셔너리 d에 없을 경우 None을 반환 |
| d.get(k, v)       | 키 k의 값을 반환하는데, 키 k가 딕셔너리 d에 없을 경우 v을 반환 |
| d.pop(k)          | 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제하는데, 키 k가 딕셔너리 d에 없을 경우 KeyError를 발생 |
| d.pop(k, v)       | 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제하는데, 키 k가 딕셔너리 d에 없을 경우 v를 발생 |
| d.update([other]) | 딕셔너리 d의 값을 매핑하여 업데이트                          |



## 복사 방법

- 할당
- 얕은 복사
- 깊은 복사



### 할당

- 대입 연산자(=)

  - 리스트 복사 확인하기

    ```python
    original_list = [1, 2, 3]
    copy_list = original_list
    print(original_list, copy list)
    
    copy_list[0] = 'hello'
    print(original_list, copy_list)
    # ['hello', 2, 3] ['hello', 2, 3]
    ```

    대입 연산자를 통한 복사는 해당 객체에 대한 객체 참조를 복사



### 얕은 복사(shallow copy)

- Slice 연산자 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사

```python
a = [1, 2, 3]
b = a[:]
print(a, b) # [1, 2, 3] [1, 2, 3]
b[0] = 5
print(a, b) # [1, 2, 3] [5, 2, 3]
```



### 깊은 복사

```python
import copy
a = [1, 2, ['a', 'b']]
b = copy.deepcopy(a)
print(a, b) # [1, 2, ['a', 'b']] [1, 2, ['a', 'b']]
b[2][0] = 0
print(a, b) # [1, 2, ['a', 'b']] [1, 2, [0, 'b']]
```

