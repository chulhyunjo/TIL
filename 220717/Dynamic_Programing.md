# 다이나믹 프로그래밍(DP)

## 개념

- 메모리를 적절하게 사용하면서 수행 시간 효율성을 비약적으로 향상 시키는 방법
- 이미 계산된 결과(작은 문제)는 별도의 영역에 저장 > 다시 계산 x
- 구현 방식 > **탑다운, 보텀업**
- **동적 계획법**이라고도 불림



## 구조

### 1. 최적 부분 구조(Optimal Substructure)

> 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결

### 

### 2. 중복되는 작은 문제(Overlapping Subproblem)

> 동일한 작은 문제를 반복적으로 해결



### 메모이제이션(Memoization) - 하향식(탑다운)

> 다이나믹 프로그래밍을 구현하는 하나의 방법

- 한 번 계산한 결과를 메모리 공간에 메모하는 기법
  -  같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다(**캐싱Cashing**)
- DP에 국한된 개념 x
- 시간 복잡도 **O(N)**



#### 탑다운 vs 보텀업(하향식 vs 상향식)

- 다이나믹 프로그래밍의 전형적인 형태는 **보텀업**
  - 결과 저장용 리스트는 **DP테이블**이라 불린다



## 접근 방식

> DP 유형임을 파악하는 것이 중요

- 그리디, 구현, 완전 탐색 등으로 아이디어 문제를 해결할 수 있는 지 파악
  - 떠오르지 않는다면 DP 활용
- 재귀로 먼저 구현 > (탑다운)작은 문제에서 구한 답이 그대로 사용되면 DP
- 일반적인 코딩 문제에서는 기본 유형의 DP문제 출제





## 문제 1) 개미 전사

> 일직선의 식량 창고를 공격한다. 인접한 식량창고가 공격받으면 바로 알아차린다.
>
> 들키지 않기 위해서 최소한 한 칸 이상 떨어진 식량 창고를 약탈해야 한다.
>
> 얻을 수 있는 식량의 최댓값을 구하는 프로그램 작성

**ai** = i번째 식량창고 까지의 최적의 해 (얻을 수 있는 식량의 최댓값)

**ki** = i번째 식량창고에 있는 식량의 양

**점화식**: ai = max(a(i-1), a(i-2)+ki

```python
n = int(input()) # n개의 식량 창고
k = list(map(int, input().split())) # 각 식량창고 안에 식량의 수

d = [0] * 100 # dP 테이플 초기화

# 다이나믹 프로그래밍 진행
d[0] = k[0]
d[1] = max(k[0],k[1])
for i in range(2, n):
    d[i] = max(d[i-2]+k[i], d[i-1])
    
# 계산값 출력
print(d[n-1])
```



## 문제 2) 1로 만들기

> 정수 X가 주어졌을 때, 정수 X에 사용할 수 있는 연산은 4가지이다.
>
> 1으로 만들기 위한 연산의 최솟값을 구하라
>
> 1. X가 5로 나누어 떨어지면, 5로 나눈다
> 2. x가 3으로 나누어 떨어지면, 3으로 나눈다
> 3. x가 2로 나누어 떨어지면, 2로 나눈다.
> 4. x에서 1을 뺀다

ai = i를 1로 만들기 위한 최소 연산 횟수

점화식: ai = min(a(i-1), a(i/2),a(i/3),a(i/5))+1

```python
# x값을 입력
x = int(input())

# dp리스트 초기화
d = [0] * 30001

# Dp 진행
for i in range(2, x+1):
    d[i] = d[i-1] + 1 # 현재의 수에 1을 빼는 경우
    if i % 2 == 0: # 2로 나뉘어 지는 경우
        d[i] = min(d[i], d[i // 2] + 1)
    if i % 3 == 0: # 3으로 나뉘어 지는 경우
        d[i] = min(d[i], d[i // 3] + 1)
    if i % 5 == 0: # 5로 나뉘어 지는 경우
        d[i] = min(d[i], d[i // 5] + 1)
        
print(d[x])
```



## 문제 3) 효율적인 화폐 구성

> N가지 종류의 화폐가 있다. 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 한다.
>
> ex) 2원, 3원 단위의 화폐가 있을 때 15원을 만들기 위해 3원을 5개 사용하는게 최소한의 개수이다.
>
> M원을 만들기 위한 최소한의 화폐 개수를 출력하는 프로그램 작성

```python
n, m = map(int, input())
# n가지 종류의 화폐, m원을 만들기
array = []
for i in range(n):
    array.append(int(input()))

# dp 리스트 초기화
d = 10001 * (m+1)
# dp 시작
d[0] = 0
for i in range(n):
    for j in range(array[i],m+1):
        if d[j - array[i]] != 10001: # (i-k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[j - array[i]] + 1)
if d[m] == 10001: # 최종적으로 M원을 만들 수 없는 경우
    print(-1)
else:
    print(d[m])
```



## 문제 4) 금광

> n x m 크기의 금광이 있다. 금광은 1 x 1 크기의 칸으로 나뉘어진다. 각 칸은 특정한 크기의 금이 있다.
>
> 채굴자는 1번 열부터 금을 캐기(어느 행에서든 출발할 수 있다.)
>
> 이후에 m - 1 번을 걸쳐 **(오른쪽 위, 오른쪽, 오른쪽 아래)** 3가지 중 하나의 위치로 이동
>
> 채굴자가 얻을 수 있는 금의 최대 크기를 출력하는 프로그램을 작성.

array(i,j) = i행 j열에 존재하는 금의 양

dp(i,j) = i행 j열까지의 최적의 해 (얻을 수 있는 금의 최대 값)

점화식: dp(i,j) = array(i,j) + max(dp(i-1, j-1), dp(i)(j-1), dp(i+1)(j-1))

```python
# 테스트 케이스(Test Case) 입력
for tc in range(int(input())):
    # 금광 정보 입력
    n, m = map(int, input().split())
    array = list(map(int, input().split()))
    # DP 테이블 초기화
    dp = []
    for i in range(0,len(array),m):
        dp.append(array[i:i + m])
    
    # DP 진행
    for j in range(1, m):
        for i in range(n):
            # 왼쪽 위에서 오는 경우
            if i == 0: left_up = 0
	        else: left_up = dp[i-1][j-1]
        	# 왼쪽 아래에서 오는 경우
            if i == n-1: left_down = 0
	        else: left_down = dp[i+1][j-1]
            # 왼쪽에서 오는 경우
            left = dp[i][j-1]
            dp[i][j] = dp[i][j] + max(left_up, left_down, left)
	result = 0
    for i in range(n):
        result = max(result, dp[i][m-1]) # 맨 오른쪽에서 가장 큰값이 결과값
    print(result)
```

