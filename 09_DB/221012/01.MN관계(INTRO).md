# 01.M:N관계

- Many to many relationships
- 한 테이블의 0개 이상의 레코드가 다른 테이블의 0개 이상의 레코드와 관련된 경우
- 양쪽 모두에서 N:1 관계를 가짐



> 데이터 모델링

- 주어진 개념으로부터 논리적인 데이터 모델을 구성하는 작업
- 물리적인 데이터베이스 모델로 만들어 고객의 요구에 따라 특정 정보 시스템의 데이터베이스에 반영하는 작업



> 용어 정리

- target model
  - 관계 필드를 가지지 않은 모델
- source model
  - 관계 필드를 가진 모델



> N:1의 한계

- 의사와 환자간 예약 시스템을 구현
- 지금까지 배운 N:1 관계를 생각해 한명의 의사에게 여러 환자가 예약할 수 있다고 모델 관계를 설정

- 각각 2명의 의사와 환자를 생성하고 환자는 서로 다른 의사에게 예약을 했다고 가정
- 1번 환자(carol)가 두 의사 모두에게 반문하려고 한다고 가정

`patient3=Patient.obects.create(name='carol', doctor=doctor2)`

- 동일한 환자지만 다른 의사에게 예약하기 위해서는 객체를 하나 더 만들어서 예약을 진행해야 함
  - 새로운 환자 객체를 생성할 수 밖에 없다
- 외래 키 컬럼에 '1, 2' 형태로 참조하는 것은 Integer 타입이 아니기 때문에 불가능하다



> 중개 모델

- 환자 모델의 외래 키를 삭제하고 별도의 예약 모델을 새로 작성
- 예약 모델은 의사와 환자에 각각 N:1 관계를 가짐

- doctor1의 예약 현황 조회
  - `doctor1.reservation_set.all()`



> Django ManyToManyField

- 환자 모델에 Django ManyToManyField 작성

```python
# hospitals/models.py

class Patient(models.Model):
    doctors = models.ManyToManyField(Doctor)
    name = models.TextField()

    def __str__(self):
        return f'{self.pk}번 환자 {self.name}'
```



- 의사 1명과 환자 2명 생성

```python
doctor1 = Doctor.objects.create(name='alice')
patient1 = Patient.objects.create(name='carol')
patient2 = Patient.ojects.create(name='dane')
```



- 예약 생성(환자가 의사에게 예약)

```shell
# patien1이 doctor1에게 예약
patient1.doctors.add(doctor1)
```



- 예약 생성 (의사가 환자를 예약)

```python
# doctor1이 patient2을 예약
doctor1.patient_set.add(patient2)
```



- 예약 취소하기(삭제)
- 기존에 해당하는 Reservation을 찾아서 지워야 했다면, 이제는 `.remove()` 사용

```python
# doctor1이 patient1 진료 예약 취소
doctor1.patient_set.remove(patient1)

# patient2가 doctor1 진료 예약 취소
patient2.doctors.remove(doctor1)
```

- Django는 ManyToManyField를 통해 중개 테이블을 자동으로 생성



> `related_name` argument

- target model이 source model을 참조할 때 사용할 manager name
- ForeignKey()의 related_name과 동일

```python
class Patient(models.Model):
    doctors = models.ManyToManyField(Doctor, related_name='patients')
    name = models.TextField()

    def __str__(self):
        return f'{self.pk}번 환자 {self.name}'

```

- related_name 설정값 확인

```python
# 1번 의사 조회하기
doctor1 = Doctor.objects.get(pk=1)

# 에러 발생(related_name 을 설정하면 기존 _set manager는 사용할 수 없음
doctor1.patient_set.all() # 오류

# 변경 후
doctor1.patients.all()
```



> `through` argument

- 중개 모델을 직접 작성하는 경우는 없을까?
  - 중개 테이블을 수동으로 지정하려는 경우 `through` 옵션을 사용하여 시용하려는 중개 테이블을 나타내는 Django 모델을 지정할 수 있음
- 가장 일반적인 용도는 **중개테이블에 추가 데이터를 사용**해 다대다 관계와 연결하려는 경우

```python
class Patien(models.Model):
        doctors = models.ManyToManyField(Doctor, related_name='patients', through='Reservation')
...

class Reservation(models.Model):
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    patient = models.ForeignKey(Patient, on_delete=models.CASCADE)
    symptom = models.TextField()
    reserved_at = models.DateTimeField(auto_now_add=True)


    def __str__(self):
        return f'{self.doctor_id}번 의사의 {self.patient_id}번 환자'
```

- 환자, 의사 생성

- 예약 생성

```python
# 1. Reservation class를 통한 예약 생성

reservation1 = Reservation(doctor=doctor1, patient=patien1, symptom='headache')
reservation1.save()

# 2. Patient 객체를 통한 예약 생성

patient2.doctor.add(doctor1, through_defaults={'symptom':'flu'})
```



- 예약 삭제

```python
doctor1.patient_set.remove(patient1)
patient2.doctors.remove(doctor1)
```



> 정리

- M : N 관계로 맺어진 두 테이블에는 변화가 없다
- Django의 ManyToManyField은 중개 테이블을 자동으로 생성함
- Django의 ManyToManyField는 M:N 관계를 맺는 두 모델 어디에 위치해도 상관 없음
  - 대신 필드 작성 위치에 따라 참조와 역참조 방향을 주의할 것
- N:1은 완전한 종속의 관계였지만 M:N은 의사에게 진찰받는 환자, 환자를 진찰하는 의사의 두가지 형태로 모두 표현이 가능한 것



