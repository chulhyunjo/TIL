# 07.연산자와 피연산자

- 연산자: 연산을 수행하는 기호
- 피연산자: 연산자의 연산 수행 대상

`x + 3` (x, 3) : 피연산자 ,+: 연산자



## 우선순위

- 하나의 식에 연산자가 둘 이상있을 때, 어떤 연산을 먼저 수행할지를 자동 결정하는 것
- 단항 연산자 > 산술 연산자> 비교 연산자 > 논리 연산자 > 삼항 연산자> 대입 연산자



- 대입 연산자는 오른쪽에서 왼쪽으로 진행
- 그 외에는 왼쪽 -> 오른쪽



1. 산술 > 비교 > 논리 > 대입, 대입은 제일 마지막에 수행된다.
2. 단항 > 이항 > 삼항. 단항 연산자는 우선순위가 이항 연산자보다 높다



## 증감 연산자

- 증감 연산자(++) 피연산자의 값을 1 증가
- 감소 연산자(--) 피연산자의 값은 1 감소
- `j = ++i` 값이 참조되기 **전에** 증가 : 전위형
- `j = i++` 값이 참조된 **후에** 증가 : 후위형





## 형 변환 연산자

- 형변환이란?

  - 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
  - (타입)피연산자

  ```java
  double d = 85.4;
  int score = (int)d; // 85
  ```

| 변환         | 수식      | 결과  |
| ------------ | --------- | ----- |
| int -> char  | (char)65  | 'A'   |
| char -> int  | (int)'A'  | 65    |
| float -> int | (int)1.6f | 1     |
| int -> float | (float)10 | 10.0f |



## 자동 형변환

> 값 손실이 없는 경우 생략 가능
>
> 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환된다.
>
> byte -> short -> int,char -> long -> float -> double

`float f = 1234; // int타입의 값을 float타입의 변수에 저장`

변수 > 리터럴 이므로 가능

`float f = (float)1234;`



`int i = 3.14f;` // 에러

`int i = (int)3.14f` // OK



```java
// byte -> int
byte b = 10;
int i = b; // 생략 가능

// int -> byte
int i2 = 300;
byte b2 = (byte)i2; // 생략 불가

// int -> byte
byte b = 100; // OK, byte타입 범위(-128, 127)의 값의 대입 *예외

int i = 100;
byte b = i; // 에러, int타입을 byte의 타입에 대입 (리터럴이 아닌 변수이므로 에러)
byte b = (byte)i; // OK, 수동 형변환 해줘야함
```



## 산술 변환

> 연산 전에 피연산자의 타입을 일치시키는 것

- 두 피연산자의 타입을 같게 일치시킨다(보다 큰 타입으로 일치)
  - long + int -> long + long
  - float + int -> float + float
  - double  + float -> double + double
- 피연산자의 타입이 int보다 작은 타입이면 int로 변환
  - byte + short -> int + int
  - char + short -> int + int



## 반올림

```java
double pi = 3.141592;
double shortPi = Math.round(pi * 1000) / 1000.0;
```



## 문자열 비교

- `==` 대신 equals()를 사용해야 한다.

```java
String str1 = "abc";
String str2 = "abc";

str1 == str2; // true
str1.equals(str2); // true

String str1 = new String("abc");
String str2 = new String("abc");

str1 == str2; // false
str1.equals(str2); // true
```

