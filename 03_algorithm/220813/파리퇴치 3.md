# 파리퇴치 3

**비슷한 문제** : [파리퇴치](https://velog.io/@chaoman5/%EC%B6%94%EA%B0%80-%EB%AC%B8%EC%A0%9C-%ED%8C%8C%EB%A6%AC-%ED%87%B4%EC%B9%98), [부분 배열의 합](https://velog.io/@chaoman5/%EC%B6%94%EA%B0%80-%EB%AC%B8%EC%A0%9C-%EB%B6%80%EB%B6%84-%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%95%A9)

:link: 링크: https://swexpertacademy.com/main/code/userProblem/userProblemDetail.do?contestProbId=AXuARWAqDkQDFARa&categoryId=AXuARWAqDkQDFARa&categoryType=CODE

N x N 배열 안의 숫자는 해당 영역에 존재하는 파리의 개체 수를 의미한다.

아래는 N=5 의 예이다.
![img](https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&fileId=AXuAR8zqDpQDFARa)

파리 킬러 스프레이를 한 번만 뿌려 최대한 많은 파리를 잡으려고 한다. 

스프레이의 노즐이 + 형태로 되어있어, 스프레이는 + 혹은 x 형태로 분사된다.

 스프레이를 M의 세기로 분사하면 노즐의 중심이 향한 칸부터 각 방향으로 M칸의 파리를 잡을 수 있다.

다음은 M=3 세기로 스프레이르 분사한 경우 파리가 퇴치되는 칸의 예로, +또는 x 중 하나로 분사된다. 뿌려진 일부가 영역을 벗어나도 상관없다.

![img](https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&fileId=AXuARjJqDmUDFARa)

한 번에 잡을 수 있는 최대 파리수를 출력하라.



> ### 입력 

가장 첫 줄에는 테스트 케이스의 개수 T
각 테스트 케이스의 첫 번째 줄에 N 과 M 이 주어지고,
다음 N 줄에 걸쳐 N x N 배열이 주어진다.



> ### 정답

```python
for tc in range(1, int(input()) + 1):
    n, m = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(n)]
    dx = [1, 0, -1, 0] # 상하 이동
    dy = [0, 1, 0, -1] # 좌우 이동
    dz1 = [1, 1, -1, -1] # 대각선 이동 1
    dz2 = [-1, 1, 1, -1] # 대각선 이동 2
 
    result = 0 # 최종 정답을 담을 변수
    for i in range(n):
        for j in range(n):
            sum1 = arr[i][j] # 상하좌우 합 담을 변수
            sum2 = arr[i][j] # 대각선 합 담을 변수
            for q in range(4):
                for w in range(1, m):
                    nx = i + dx[q] * w # 상하 이동
                    ny = j + dy[q] * w # 좌우 이동
                    nz1 = i + dz1[q] * w # 대각선1
                    nz2 = j + dz2[q] * w # 대각선 2
                    if 0 <= nx < n and 0 <= ny < n:  # 범위를 벗어나는지 확인
                        sum1 += arr[nx][ny]
 
                    if 0 <= nz1 < n and 0 <= nz2 < n: # 범위를 벗어나는지 확인
                        sum2 += arr[nz1][nz2]
            if result < sum1: # 최종 결과보다 현재 구한 범위의 합이 더 클 경우 실행 (상하좌우 합)
                result = sum1
            if result < sum2: # 최종 결과보다 현재 구한 범위의 합이 더 클 경우 실행 (대각선 합)
                result = sum2
    print(f'#{tc} {result}')
```



> ### 정답 설명

이 문제는 dx,dy를 활용하고, 더해서 대각선 방향도 확인할 수 있도록 해야한다.

그래서 `dz1, dz2`를 활용했다.

```python
dx = [1, 0, -1, 0] # 상하 이동
dy = [0, 1, 0, -1] # 좌우 이동
dz1 = [1, 1, -1, -1] # 대각선 이동 1
dz2 = [-1, 1, 1, -1] # 대각선 이동 2
```

[dz1, dz2] 를 활용하면 [1,-1], [1,1], [-1,1], [-1,-1] 대각선 4방향을 확인할 수 있다.



```python
for i in range(n):
    for j in range(n):
        sum1 = arr[i][j] # 상하좌우 합 담을 변수
        sum2 = arr[i][j] # 대각선 합 담을 변수
```

sum1, sum2를 각각 상하좌우와 대각선의 합을 담을 변수를 선언한다.



> 합 구하기

```python
for q in range(4):
    for w in range(1, m): 
    # m이 2일 경우 현재의 위치 뿐만 아니라 노즐의 중심이 향한 칸부터 각 방향 (M-1)칸의 파리를 잡는다
        nx = i + dx[q] * w # 상하 이동
        ny = j + dy[q] * w # 좌우 이동
        nz1 = i + dz1[q] * w # 대각선1
        nz2 = j + dz2[q] * w # 대각선 2
        if 0 <= nx < n and 0 <= ny < n:  # 범위를 벗어나는지 확인
            sum1 += arr[nx][ny]
        if 0 <= nz1 < n and 0 <= nz2 < n: # 범위를 벗어나는지 확인
            sum2 += arr[nz1][nz2]
```

`nx, ny` 는 `dx, dy`를 이용해서 상,하,좌,우 방향으로 이동했을 때 다음의 인덱스 위치를 나타낸다.

`nz1, nz2`도 마찬가지로 `dz1, dz2`를 이용해서 대각선 방향으로 이동했을 때 다음의 인덱스 위치를 나타낸다.

이제 이동할 인덱스 `nx, ny, nz1, nz2`가 배열안의 범위에 있을 때 각자의 합을 `sum1, sum2`에 더하게 된다.



`nx, ny, nz1, nz2`를 각각 구할 때 뒤에 w를 곱한 것은  노즐의 중심으로 부터 M칸의 파리를 잡을 수 있기 때문이다.

만약 `M=3`인 경우에는, 노즐의 중심으로부터 상,하,좌,우,대각선 방향으로 2칸을 더 죽이기 때문에 `for w in range(1,m):` 반복문을 통해 `1칸, 2칸`을 이동해서 값을 더할 수 있다.



```python
if result < sum1: # 최종 결과보다 현재 구한 범위의 합이 더 클 경우 실행 (상하좌우 합)
    result = sum1
if result < sum2: # 최종 결과보다 현재 구한 범위의 합이 더 클 경우 실행 (대각선 합)
    result = sum2
```

