# 거품 정렬

### [문제 설명]

N 개의 정수를 거품 정렬(버블 정렬)을 사용해 오름차순으로 정렬한다.

두 수의 자리를 바꾼 횟수를 출력해야 하는 프로그램을 만들어라.



### [입력]

첫 줄에 테스트 케이스 T

다음 줄부터 테스트케이스 별로 첫 줄에는 N, 다음 줄에 0이상 10억 이하의 정수 N개가 빈칸으로 구분된다.

`1 <= T <= 10, 5 <= N <= 1000`



### [출력]

#과 테스트 케이스 번호, 빈칸에 이어 교환 횟수를 출력



### [정답]

```python
for tc in range(1,int(input())+1):
    n = int(input())
    arr = list(map(int,input().split()))
 
    cnt = 0
    for i in range(n-1, 0, -1):
        for j in range(i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                cnt += 1
    print(f'#{tc} {cnt}')
```



### [답안 설명]

`for tc in range(1,int(input())+1)`

첫 줄의 테스트 케이스 tc값을 입력받는다.



```python
n = int(input()) # 리스트의 크기 n
arr = list(map(int,input().split())) # 정렬할 리스트를 받을 변수
cnt = 0 # 숫자를 바꾼 횟수를 세어야 하므로 cnt변수를 이용
```



```python
for i in range(n-1, 0, -1): # 정렬될 구간의 끝
    for j in range(i): # 비교할 원소 중 왼쪽 원소의 인덱스
        if arr[j] > arr[j+1]: # 왼쪽 원소가 더 크면
            arr[j], arr[j+1] = arr[j+1], arr[j] # 교환
            cnt += 1 # 교환을 했으므로 횟수 + 1
```

버블 정렬 과정

- 첫 번째 원소부터 인접한 원소 끼리 계속 자리를 교환하면서 **맨 마지막 자리**까지 이동.
- 한 단계가 끝날 때 마다 가장 큰 원소가 마지막 자리로 정렬하게 된다.



`for i in range(n-1, 0, -1)` 정렬될 구간의 끝을 의미 한다.

한 단계가 끝날 때 마다 가장 큰 원소가 마지막 자리로 정렬되기 때문에 끝 인덱스는 n-1 -> n-2 -> .... -> 1이 된다.

