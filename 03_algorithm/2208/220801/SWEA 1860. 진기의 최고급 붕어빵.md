출처[SW Expert Academy](https://swexpertacademy.com/main/code/problem/problemDetail.do?problemLevel=3&contestProbId=AV5LsaaqDzYDFAXc&categoryId=AV5LsaaqDzYDFAXc&categoryType=CODE&problemTitle=&orderBy=FIRST_REG_DATETIME&selectCodeLang=PYTHON&select-1=3&pageSize=10&pageIndex=9)

# SWEA 1860. 진기의 최고급 붕어빵

### [문제 설명]

진기는 붕어빵을 보통 사람들에게는 팔지 않는다.

그는 무조건 예약제로만 손님을 받으며, 예약을 하려는 손님들은 진기의 까다로운 자격 검증에서 합격해야만 붕어빵을 맛 볼 자격을 얻는다.

그래서 오늘은 N명의 사람이 자격을 얻었다.

진기는 0초부터 붕어빵을 만들기 시작하며, M초의 시간을 들이면 K개의 붕어빵을 만들 수 있다.

서빙은 진기가 하는 것이 아니기 때문에, 붕어빵이 완성되면 어떤 시간 지연도 없이 다음 붕어빵 만들기를 시작할 수 있다.

0초 이후에 손님들이 언제 도착하는지 주어지면, 모든 손님들에게 기다리는 시간없이 붕어빵을 제공할 수 있는지 판별하는 프로그램을 작성하라.



### **[입력]**

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 세 자연수 N, M, K(1 ≤ N, M, K ≤ 100)가 공백으로 구분되어 주어진다.

두 번째 줄에는 N개의 정수가 공백으로 구분되어 주어지며,

각 정수는 각 사람이 언제 도착하는지를 초 단위로 나타낸다. 각 수는 0이상 11,111이하이다.



### [출력]

모든 손님에 대해 기다리는 시간이 없이 붕어빵을 제공할 수 있으면 “Possible”을, 아니라면 “Impossible”을 출력한다.



### [정답]

```python
def count_bread(N, customer, M, K):
    for i in range(N):
        total_bread = (customer[i] // M) * K
        if total_bread < i + 1:
            return 'Impossible'
    return 'Possible'


for tc in range(1, int(input()) + 1):
    n, m, k = map(int, input().split())
    array = sorted(list(map(int, input().split())))
    result = count_bread(n, array, m, k)
    print(f'#{tc} {result}')
```



#### [정답 설명]

N : 총 손님 수

M, K : M 분당 K개의 빵을 만든다.



```python
def count_bread(N, customer, M, K):
    for i in range(N):
        total_bread = (customer[i] // M) * K
        if total_bread < i + 1:
            return 'Impossible'
    return 'Possible'
```

손님이 대기하지 않고 빵을 받아가기 위해서는 도착 시간전에 빵이 준비되어 있어야한다.

그래서 i번째 손님이 왔을 때 준비된 빵을 (customer[i] // M) * K이다.

ex) 7분에 왔을때 M =3 K = 2이면

7분에 준비된 빵은 6분에 4개이다.

(7 // 3) * 2 = 4

그래서 준비된 빵이 손님의 수보다 적을 경우 'Impossible'출력 많으면 'Possible'



```python
for tc in range(1, int(input()) + 1):
    n, m, k = map(int, input().split())
    array = sorted(list(map(int, input().split())))
    result = count_bread(n, array, m, k)
    print(f'#{tc} {result}')
```

array를 정렬해서 뽑는 이유는 손님이 오는 시간은 정렬되지 않은 상태로 입력이 된다.

그래서 정렬을 받아 늦게 오는 손님이 뒤쪽에 정렬되도록 한다.

위에서 만든 count_bread()함수로 result 값을 return 받는다.